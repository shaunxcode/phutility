       __               __         ___        __                
      /\ \             /\ \__  __ /\_ \    __/\ \__             
 _____\ \ \___   __  __\ \ ,_\/\_\\//\ \  /\_\ \ ,_\  __  __    
/\ '__`\ \  _ `\/\ \/\ \\ \ \/\/\ \ \ \ \ \/\ \ \ \/ /\ \/\ \   
\ \ \L\ \ \ \ \ \ \ \_\ \\ \ \_\ \ \ \_\ \_\ \ \ \ \_\ \ \_\ \  
 \ \ ,__/\ \_\ \_\ \____/ \ \__\\ \_\/\____\\ \_\ \__\\/`____ \ 
  \ \ \/  \/_/\/_/\/___/   \/__/ \/_/\/____/ \/_/\/__/ `/___/> \
   \ \_\                                                  /\___/
    \/_/                                                  \/__/ 

Phutility is a collection of tools to make life in php more livable. 
Initially this means Invokable which is a utlity for creating simple 
callbacks w/o having to define a function. 

i.e. 

$collection->map(function($i) use($var1, $var2) { 
    return $i->someMethod()->someOther($var1)->someOther($var2);
});

Can become: 

use Phutility\Invokable as I;

$collection->map(I::someMethod()->someOther($var1)->someOther($var2));

As you may have inferred Invokable is a class which builds up a stack using __call and __get
and then further, implements the __invoke method so it may be used in any context
which an anonymous function would other wise. 

You could even do things like:

$x = I::callMethod(30)->secondMethod($arg2);

$x($y);
$x($z);

Which is equivelant to:

$y->someMethod(30)->secondMethod($arg2);
$z->someMethod(30)->secondMethod($arg2);

