 ____     __  __   __  __   ______  ______   __     ______  ______  __    __ 
/\  _`\  /\ \/\ \ /\ \/\ \ /\__  _\/\__  _\ /\ \   /\__  _\/\__  _\/\ \  /\ \
\ \ \L\ \\ \ \_\ \\ \ \ \ \\/_/\ \/\/_/\ \/ \ \ \  \/_/\ \/\/_/\ \/\ `\`\\/'/
 \ \ ,__/ \ \  _  \\ \ \ \ \  \ \ \   \ \ \  \ \ \  __\ \ \   \ \ \ `\ `\ /' 
  \ \ \/   \ \ \ \ \\ \ \_\ \  \ \ \   \_\ \__\ \ \L\ \\_\ \__ \ \ \  `\ \ \ 
   \ \_\    \ \_\ \_\\ \_____\  \ \_\  /\_____\\ \____//\_____\ \ \_\   \ \_\
    \/_/     \/_/\/_/ \/_____/   \/_/  \/_____/ \/___/ \/_____/  \/_/    \/_/

Phutility is a collection of tools to make life in php more livable. 
Initially this means Invokable which is a utility for creating simple 
callbacks w/o having to define a function.

$collection->map(function($i) use($var1, $var2) { 
    return $i->someMethod()->someOther($var1)->someOther($var2);
});

Can become: 

use Phutility\Invokable as I;

$collection->map(I::someMethod()->someOther($var1)->someOther($var2));

As you may have inferred Invokable is a class which builds up a stack using __call and __get
and then further, implements the __invoke method so it may be used in any context
which an anonymous function would other wise. 

You could even do things like:

$x = I::callMethod(30)->secondMethod($arg2);

$x($y);
$x($z);

Which is equivelant to:

$y->someMethod(30)->secondMethod($arg2);
$z->someMethod(30)->secondMethod($arg2);

Obj is an alternative object model based more upon self (http://selflanguage.org/).
You can create new objects:

use Phutility\Obj;

$obj = Obj::create(
	'age', 30, 
	'name', 'peter',
	'sayWord', function($self, $word) {
		echo "{$self->name} says {$word}";
	}
);

You can access any of the slots like a normal object:
$obj->age += 40; 
$obj->sayWord("carrot");

You can "mixin" or "extend" an object by adding a parent:

$obj->addParent(Obj::create(
	'doubleAgePlus', function($self, $plus) {
		return ($self->age * 2) + $plus;
	})
);

You can also add multiple parents at once:
$obj->addParents($parent1, $parent2);

You can "clone" an object, which is essentially how you create an instance in normal oo terms. 
You can over-ride any properties that you want when creating a clone. 

$otherObj = $obj('age', 40);

The larger question is obviously "why". Well, mainly to explore the limits of class-less oo. 
There is a decent potential for cool meta-programming as well. The fact that you can pass 
around these objects as if they are normal php objects is advantageous in that it does not 
limit you to staying with in the confines of Phutility\Obj. 

With the Obj approach higher order oo is possible. i.e. functions which return objects 
based upon runtime values. Previously in php this was only possible by massively abusing
__call and other magic methods or by the use of eval, code generation etc. 

Imagine you want to have an object which represents a table row and has getter/setters
for each field. 

function createTableObject($name, $fields) {
	$obj = Obj::create(
		'table', $name,
		'data', array(),
		'types', array());
	
	$buildGetter = function($fname) { 
		return function($self) use($fname) { 
			return $self->data[$fname];
		};
	};
	
	$buildSetter = function($fname) {
		return function($self, $value) use($fname) {
			$self->data[$fname] = $value;
			return $self;
		};
	};
	
	foreach($fields as $field => $type) {
		$obj->types[$field] = getType($type);
		$obj->{'get' . ucfirst($field)} = $buildGetter($field);
		$obj->{'set' . ucfirst($field)} = $buildSetter($field);
	}
	
	return function($data) use($obj) { 
		return $obj('data', $data);
	};
}

$color = createTableObject('Color', array('name' => 'String', 'hex' => 'String'));
$red = $color(array('name' => 'Red', 'hex' => '#ff0000'));

echo $red->getName();
echo $red->setHex('#ff00ff')->getHex();

The real point is that it looks like an object and acts like an object yet we can
add new methods at any time. Say we want to allow saving of the object via some sort
of entity manager. 

$red->entityManager = $em;
$red->save = function($self) {
	$self->entityManager->persist($self->data);
	$self->entityManager->flush();
	return $self;
};

$red->save();