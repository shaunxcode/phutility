 ____     __  __   __  __   ______  ______   __     ______  ______  __    __ 
/\  _`\  /\ \/\ \ /\ \/\ \ /\__  _\/\__  _\ /\ \   /\__  _\/\__  _\/\ \  /\ \
\ \ \L\ \\ \ \_\ \\ \ \ \ \\/_/\ \/\/_/\ \/ \ \ \  \/_/\ \/\/_/\ \/\ `\`\\/'/
 \ \ ,__/ \ \  _  \\ \ \ \ \  \ \ \   \ \ \  \ \ \  __\ \ \   \ \ \ `\ `\ /' 
  \ \ \/   \ \ \ \ \\ \ \_\ \  \ \ \   \_\ \__\ \ \L\ \\_\ \__ \ \ \  `\ \ \ 
   \ \_\    \ \_\ \_\\ \_____\  \ \_\  /\_____\\ \____//\_____\ \ \_\   \ \_\
    \/_/     \/_/\/_/ \/_____/   \/_/  \/_____/ \/___/ \/_____/  \/_/    \/_/

Phutility is a collection of tools to make life in php more livable. Primarily
it is meant to scratch the itch of a beaver who want's to play guitar but is 
stuck trying to play keyboard whilst pretending to be a duck 9-5. 
http://30.media.tumblr.com/tumblr_l3wek2i9FK1qzev6go1_400.jpg

Invokable is a utility for creating simple callbacks when dealing w/ objects.

$collection->map(function($i) use($var1, $var2) { 
    return $i->someMethod()->someOther($var1)->someOther($var2);
});

Becomes:

use Phutility\Invokable as I;

$collection->map(I::someMethod()->someOther($var1)->someOther($var2));

As you may have inferred Invokable is a class which builds up a stack using __call and __get
and then further, implements the __invoke method so it may be used in any context
which an anonymous function would other wise. 

Further:

$x = I::callMethod(30)->secondMethod($arg2);

$x($y);
$x($z);

Which is equivalent to:

$y->someMethod(30)->secondMethod($arg2);
$z->someMethod(30)->secondMethod($arg2);

Obj is an alternative/classless object model based more upon self (http://selflanguage.org/).

Create a new object:

use Phutility\Obj;

$obj = Obj::create(
	'age', 30, 
	'name', 'peter',
	'sayWord', function($self, $word) {
		echo "{$self->name} says {$word}";
	}
);

You can access any of the slots like a normal object:
$obj->age += 40; 
$obj->sayWord("carrot");

You can "mixin" or "extend" an object by adding a parent:

$obj->addParent(Obj::create(
	'doubleAgePlus', function($self, $plus) {
		return ($self->age * 2) + $plus;
	})
);

You can add multiple parents at once:
$obj->addParents($parent1, $parent2);

You can "clone" an object, which is essentially how you create an instance in "classful" oo terms. 
You can over-ride any properties that you want when creating a clone. 

$otherObj = $obj('age', 40);

The larger question is obviously "why"? Well, mainly to explore the limits of class-less oo. 
There is a decent potential for cool meta-programming as well. The fact that you can pass 
around these objects as if they are normal php objects is advantageous in that it does not 
limit you to staying with in the confines of Phutility\Obj. 

With the Obj approach higher order oo is possible. i.e. functions which return objects 
based upon runtime values. Previously in php this was only possible by massively abusing
__call and other magic methods or by the use of eval, code generation etc. 

Imagine you want to have an object which represents a table row and has getter/setters
for each field. 

function createTableObject($name, $fields) {
	$obj = Obj::create(
		'table', $name,
		'data', array(),
		'types', array());
	
	$buildGetter = function($fname) { 
		return function($self) use($fname) { 
			return $self->data[$fname];
		};
	};
	
	$buildSetter = function($fname) {
		return function($self, $value) use($fname) {
			$self->data[$fname] = $value;
			return $self;
		};
	};
	
	foreach($fields as $field => $type) {
		$obj->types[$field] = getType($type);
		$obj->{'get' . ucfirst($field)} = $buildGetter($field);
		$obj->{'set' . ucfirst($field)} = $buildSetter($field);
	}
	
	return function($data) use($obj) { 
		return $obj('data', $data);
	};
}

$color = createTableObject('Color', array('name' => 'String', 'hex' => 'String'));
$red = $color(array('name' => 'Red', 'hex' => '#ff0000'));

echo $red->getName();
echo $red->setHex('#ff00ff')->getHex();

It is important to note that it looks like an object and acts like an object yet we can
add new methods at any time. Say we want to allow saving of the object via some sort
of entity manager. 

$red->entityManager = $em;
$red->save = function($self) {
	$self->entityManager->persist($self->data);
	$self->entityManager->flush();
	return $self;
};

$red->save();

As you can see it would be relatively trivial to modify the createTableObject to build
in validation inside of the setter etc.

The Obj class is essentially a meta-object-protocol in that multiple inheritance behavior,
method dispatch etc. can be customized. One could extend Obj and over-ride the getSlot 
method to behave in any way that you would like. 