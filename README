       __                         __                                                 
      /\ \                       /\ \                                                
 _____\ \ \___   __  __   ___    \_\ \     __  _ __  ____   ___    ___   _ __   __   
/\ '__`\ \  _ `\/\ \/\ \/' _ `\  /'_` \  /'__`\\`'__\',__\ /'___\ / __`\/\`'__\'__`\ 
\ \ \L\ \ \ \ \ \ \ \_\ \\ \/\ \/\ \L\ \/\  __/ \ \/\__, `\\ \__//\ \L\ \ \ \/\  __/ 
 \ \ ,__/\ \_\ \_\ \____/ \_\ \_\ \___,_\ \____\ \_\/\____/ \____\ \____/\ \_\ \____\
  \ \ \/  \/_/\/_/\/___/ \/_/\/_/\/__,_ /\/____/\/_/\/___/ \/____/\/___/  \/_/\/____/
   \ \_\                                                                             
    \/_/                                                                             

phunderscore is a utility-belt library for php that provides 
support for the usual functional suspects (each, map, reduce, filter...) 
without extending any core php objects.

Obviously this is a tribute to http://documentcloud.github.com/underscore/

However there are some other aspects which are php-centric which do not translate 
to/from javascript e.g. Invokable class which is a nice utility
which you can integrate into collection/entity classes. 

i.e. 

$collection->map(function($i) use($var1, $var2) { 
    return $i->someMethod()->someOther($var1)->someOther($var2);
});

Can become: 

use Phunderscore\Invokable as I;

$collection->map(I::someMethod()->someOther($var1)->someOther($var2));

As you may have inferred Invokable is a class which builds up a stack using __call and __get
and then further, implements the __invoke method so it may be used in any context
which an anonymous function would other wise. 

You could even do things like:

$x = I::callMethod(30);

$x($y);
$x($z);

Which is equivelant to:

$y->callMethod(30);
$z->callMethod(30);